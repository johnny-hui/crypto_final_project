import select
import sys
import threading
from models.CipherPlayground import CipherPlayground
from utility.cipher_utils import get_user_command_option
from utility.client_server_utils import (accept_new_connection_handler, display_menu, receive_data,
                                         get_user_menu_option, close_application, view_current_connections,
                                         send_message, send_file, send_file_bulk)
from utility.constants import INIT_SERVER_MSG, INIT_SUCCESS_MSG, MODE_SERVER, INPUT_PROMPT, USER_INPUT_THREAD_NAME, \
    USER_INPUT_START_MSG, USER_MENU_THREAD_TERMINATE, \
    SELECT_ONE_SECOND_TIMEOUT, SELECT_CLIENT_SEND_MSG_PROMPT, SERVER_MAX_MENU_ITEM_VALUE, \
    SERVER_MIN_MENU_ITEM_VALUE, SELECT_CLIENT_SEND_FILE_PROMPT, SEND_FILE_MODE_PROMPT
from utility.ec_keys_utils import generate_keys
from utility.init import parse_arguments, initialize_socket


class Server:
    """A class representing the server

    @attention: Design Decision
        Server cannot connect to other clients or servers
        (only accept connections)

    Attributes:
        ip - The ip address
        port - The port number
        name - The name of the server
        own_socket - The socket object for the server
        pvt_key - The private key generated by ECDH (via. brainpoolP256r1)
        pub_key - The public key generated by ECDH (via. brainpoolP256r1)
        fd_list - A list of file descriptors to monitor (using select() function)
        client_dict - A dictionary containing information about each connected client{IP: (name, shared secret key, IV)}
        terminate - A boolean flag that determines if the server should terminate
    """
    def __init__(self):
        """
        A constructor for a Server class object.
        """
        print(INIT_SERVER_MSG)
        self.name, self.ip, self.port = parse_arguments(is_server=True)
        self.own_socket = initialize_socket(self.ip, self.port)
        self.pvt_key, self.pub_key = generate_keys(mode=MODE_SERVER)
        self.fd_list = [self.own_socket]  # => Monitored by select()
        self.client_dict = {}  # Format {IP: [name, shared_secret, IV, cipher mode, cipher object]}
        self.terminate = False
        print(INIT_SUCCESS_MSG)

    def start(self):
        """
        Starts the server and monitors any incoming connections
        and messages from existing clients.

        @return: None
        """
        self.__start_user_menu_thread()

        while self.terminate is False:
            readable, _, _ = select.select(self.fd_list, [], [], SELECT_ONE_SECOND_TIMEOUT)

            for sock in readable:
                if sock is self.own_socket:
                    accept_new_connection_handler(self, sock)
                    display_menu(is_server=True)
                    print(INPUT_PROMPT)
                else:
                    receive_data(self, sock, is_server=True)

    def __start_user_menu_thread(self):
        """
        Starts a thread for handling user input
        for the menu.

        @return: None
        """
        input_thread = threading.Thread(target=self.__menu, name=USER_INPUT_THREAD_NAME)
        input_thread.start()
        print(USER_INPUT_START_MSG)

    def __menu(self):
        """
        Displays the menu and handles user input
        using select().

        @return: None
        """
        inputs = [sys.stdin]
        print("=" * 80)
        display_menu(is_server=True)
        print(INPUT_PROMPT)

        while not self.terminate:
            readable, _, _ = select.select(inputs, [], [])

            # Get User Command from the Menu and perform the task
            for fd in readable:
                if fd == sys.stdin:
                    command = get_user_menu_option(fd, SERVER_MIN_MENU_ITEM_VALUE, SERVER_MAX_MENU_ITEM_VALUE)
                    self.__handle_command(command)

    def __handle_command(self, command: int):
        """
        Handles and performs user menu command options
        for the Server.

        @param command:
            An integer representing the menu option
            to be performed

        @return: None
        """
        def send_message_to_specific_client():
            client_sock, cipher, _, _ = self.__get_specific_client(prompt=SELECT_CLIENT_SEND_MSG_PROMPT)
            send_message(client_sock, cipher)

        def send_file_to_specific_client():
            client_sock, cipher, ip, name = self.__get_specific_client(prompt=SELECT_CLIENT_SEND_FILE_PROMPT)
            if client_sock is None:
                return None
            else:
                send_type = get_user_command_option(opt_range=tuple(range(3)), msg=SEND_FILE_MODE_PROMPT)
                if send_type != 0:
                    self.fd_list.remove(client_sock)
                    if send_type == 1:
                        send_file(ip, name, client_sock, cipher)
                    elif send_type == 2:
                        send_file_bulk(ip, name, client_sock, cipher)
                    self.fd_list.append(client_sock)

        def terminate_application():
            close_application(self)
            print(USER_MENU_THREAD_TERMINATE)

        def perform_post_action_steps():
            if command == 5:  # If terminate application, don't print the menu again
                return None
            display_menu(is_server=True)
            print(INPUT_PROMPT)

        actions = {
            1: lambda: send_message_to_specific_client(),
            2: lambda: send_file_to_specific_client(),
            3: lambda: view_current_connections(self, is_server=True),
            4: lambda: CipherPlayground().start(),
            5: lambda: terminate_application(),
        }
        action = actions.get(command)
        if action:
            action()
            perform_post_action_steps()

    def __get_specific_client(self, prompt: str):
        """
        Prompts user to choose a specific client to
        send a message to.

        @attention Use Case:
            Used by Server class

        @param prompt:
            A string containing the prompt

        @return: tuple(fd, shared_secret, iv)
            A tuple containing the client socket, shared secret and
            the initialization vector
        """
        if len(self.fd_list) > 1:
            # Print current peers
            view_current_connections(self, is_server=True)

            while True:
                try:
                    # Prompt user selection for a specific client
                    client_index = int(input(prompt.format(1, len(self.client_dict))))
                    while client_index not in range(1, (len(self.client_dict) + 1)):
                        print("[+] ERROR: Invalid selection range; please enter again.")
                        client_index = int(input(prompt.format(1, len(self.client_dict))))

                    # Get information of the client (from dictionary)
                    ip, info = list(self.client_dict.items())[client_index - 1]
                    cipher = info[-1]
                    name = info[0]

                    # Iterate over the list of sockets and find the corresponding one
                    for socket in self.fd_list[1:]:
                        if socket.getpeername()[0] == ip:
                            return socket, cipher, ip, name

                except (ValueError, TypeError) as e:
                    print(f"[+] ERROR: An invalid selection provided ({e}); please enter again.")
        else:
            print("[+] ERROR: There are currently no connected clients to perform the selected option!")
            return None, None, None, None
